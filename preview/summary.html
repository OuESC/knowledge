<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<!-- 1.输入url后的加载过程
		查找域名对应IP地址
		建立连接(TCP的三次握手)
		构建网页
		断开连接(TCP的四次挥手)

	2.四次挥手
		(1) 主机向服务器发送一个断开连接的请求；

		(2) 服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机)

		(3) 服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据)

		(4) 主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接；

	3.你有哪些性能优化的方法

	（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。

	 （2） 前端模板JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

	  （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

	  （4） 当需要设置的样式很多时设置className而不是直接操作style。

	  （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

	  （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。

	  （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。
	
	4.js中常用的内置对象有哪些？并列举不少于5个的常用方法

		(1) arguments 函数参数集合
				arguments.callee 当前正在运行的函数
				arguments.length 实参的个数
		
		(2) Array 数组
				length 动态获取数组长度
				join() 将一个数组转成字符串，返回一个字符串
				reverse() 翻转数组顺序
				sort() 给数组排序
				concat() 拼接数组
				push(参数) 从后添加元素，返回新数组的个数
				unshift(参数) 从前面添加元素，返回新数组的个数
				pop() 不传参，从后面删除元素，返回删除的那个元素，并将长度减去1
				shift() 不传参，从前面删除元素，返回删除的那个元素，并将长度减去1
				slice(索引，索引) 从第几项到第几项，返回这部分数组项，不影响原来的数组
				splice(索引，个数，添加项) 从第几项开始删除几个，在删除的位置添加元素
				toString() 把数组转换成字符串
				delete 运算符 只能删除数组元素的值，所占空间还在，总长度没变(arr.length) 

		(3) Boolean 布尔对象
				Boolean.toString() 将布尔值转换成字符串
				Boolean.valueOf() boolean对象的布尔值

		(4) Function 
				.call() 
				.apply() 将函数作为对象的方法调用
				.length 
				.prototype
				.toString()
				.arguments[] 传递给函数的参数
		(5) Object 
				.constructor 对象的构造函数
				.hasOwnProperty() 检测是否对象自身的属性
				.isPrototypeOf() 
				.propertyIsEnumerable()
				.toLocalString() 返回对象的本地字符串表示
				.toString() 定义一个对象的字符串表示
				.valueOf() 指定对象的原始值
		(6) String
				toLowerCase() 转小写
				toUpperCase() 转大写
				charAt(index) 返回指定下标的一个字符，如果没有找到，返回空字符串
				substr(索引，个数) 从第几位，截取几个
				substring(索引，索引)  
				split() 将一个字符串转换成数组
				charCodeAt() 返回字符串中的第n个字符的代码
				indexOf() 检测字符串是否存在，不存在就返回-1
				lastIndexOf() 最后一次出现的地方
				replace() 替换，但是只是替换一次
				valueOf() 返回字符串的值
		(7) Date
				Date.getDate() 返回一个月中的某一天
				Date.getDay() 返回一周中的某一天
				Date.getFullYear() 返回date对象的年份字段
				Date.getHours() 小时
				.getMinutes() 分钟
				.getMonth() 月份
				.getSeconds() 秒数
				.getMilliSeconds() 毫秒
				以上的get都是获取，也可以set设置
		(8) Math
				Math 是一个静态对象
				Math.PI
				Math.abs()
				Math.ceil() 向上取整(整数加1，小数去掉)
				Math.floor() 向下取整(直接去掉小数)
				Math.round() 四舍五入
				Math.pow(x,y)  求x的y次方
				Math.sqrt() 求平方根
		(9) RegExp
				RegExp.exec() 通用的匹配模式
				RegExp.global 正则表达式是否全局匹配
				RegExp.ignoreCase 正则表达式是否区分大小写
				RegExp.lastIndex 下次匹配的起始位置
				RegExp.source 正则表达式的文本
				RegExp.test() 检测一个字符串是否匹配某个模式
				RegExp.toString() 把正则表达式转换成字符串

		(10) Number 
				.toString() 将数字转换成字符串
				.valueOf() 返回原始数值

	5.in 运算符和 delete 运算符
		in：判断对象中是否能够访问到某个属性，能返回true，不能返回false
			in只看对象中有没有指定的属性，而不管属性的值

		delete 删除 用于删除对象的属性
			语法：delete 对象.属性
			对于数组来说，索引号就是键
			使用delete 删除数组索引号的时候，是不会改变数组长度的

	6.基本包装类型
		简单数据类型（值类型）
	​	number、string、boolean、null、undefined

		复杂数据类型（引用类型）
	​	Object、Array、Function

		问题1：简单数据类型有属性和方法吗？
		简单数据类型，没有任何的属性和方法的

		复杂数据类型：有属性和方法的

		问题2：给我解释一下  `var str = "abc"; console.log(str.length);`
		因为基本包装类型

		基本包装类型的概念：js为了我们使用字符串方便，在我们使用字符串的时候，可以直接调用字符串的方法，会把字符串包装成一个字符串对象。

		1. 会把根据基本类型创建一个对象  var str = new String("abc");
		2. 返回创建的这个对象对应的结果
		3. 销毁创建出来的这个对象


	7. Dom的常用方法	
		1.document.getElementById('demo');
		2.document.getElementsByTagName('input');获取页面上所有的input标签
		3.box.getElementsByTagName('input');获取box下的所有input标签
		4.innerText() 获取的仅仅是内容，会丢弃html标签，不识别html标签
		  innerHtml() 获取内容，还包括html标签，识别标签
		5.classList.remove('current') 
		  classList.add('current') 
		  classList.toggle('')
		  parent.appendChild(newChild) 添加节点
		  parent.removeChild(child) 删除节点

		6.标签的自定义属性
		  setAttribute(name,value) 自定义的设置必须是这种方法
		  getAttribute(name)获取和移除(可以是自定义也可以是固有的)
		  removeAttribute(name)
		7.children[0] 第一个子孩子，不包括孙子
		  nextElementSibling 下一个兄弟元素
		  previousElementSibling 上一个兄弟元素
		  firstElementChild 第一个孩子元素
		  lastElementChild 最后一个额孩子元素

		  nextSibling 下一个兄弟节点
		  previousSibling 上一个兄弟节点
		  lastChild 最后一个孩子节点
		  firstChild 第一个孩子节点

		  上面的带有element的都是有兼容问题的，不带的都是获取节点

		  var newNode = node.cloneNode(true/false) 克隆节点
		  parent.insertBefore(newChild,refChild) 添加节点到最前面
		  var element = document.createElement('tagName') 创建节点

		8.offset 家族
			offsetWidth offsetHeight 这个常用
				获取的是真实宽高，数值类型，可直接参与运算，只读属性，只能获取，不能设置  包括 width+padding+border
			offsetLeft offsetTop 
				获取的是相对于offsetParent的真实距离，数值类型，直接参与运算，只读，只能获取，不能设置
			offsetParent 与 parentNode 
				offsetParent 找的是最近的有定位的父元素(干爹)
				parentNode 找的是直接父元素(亲爹)
			style属性也可以设置获取宽高以及距离，但是style获取的是带有单位的字符串，参与运算要parseInt，style属性只能获取
				 行内样式

		9.scroll 家族
			scrollWidth scrollHeight
				是盒子内容的真实宽高，与盒子的大小没有关系，仅仅与盒子的内容相关
			scrollLeft scrollTop  这个常用
				是盒子内容被滚动条卷去的左侧的宽度，以及卷去的头部的高度
			onscroll 事件
				对于有滚动条的盒子，可以使用onscroll注册滚动事件，每滚动一像素，就会触发该事件
			获取页面滚动坐标有兼容性，封装函数
				function scroll() {
					return {
						top:window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 ,
						left:window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0
					}
				}
				console.log(scroll().top);
				console.log(scroll().left);
		
		10.client 家族
			clientWidth 与 clientHeight 
				偏移：offsetWidth: width + padding + border 
				卷曲：scrollWidth: width + padding 不包含border，内容的大小
				可视：clientWidth: width + padding 不包含border
				如果内容没有超出盒子范围，那么clientWidth 与 scrollWidth 相同
			clientLeft 与 clientTop 
				完全没有用，他们就是border-top 与 border-left ；
				但是如果有滚动条，还会包含滚动条的宽度
			获取页面可视宽高的兼容性封装
			function client() {
				return {
					width:window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,
					height:window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0
				}
			}

		11.总结：
			offset家族是用来获取元素自身的大小和位置
			scroll家族是用来获取元素内容的大小和位置
			client家族是用来获取元素可视区域的大小

		  
    8. Dom 绑定事件   事件源.事件 = function() {事件处理程序} ;
		点击事件：onclick
	  	双击事件：ondbclick
	 	鼠标经过：onmouseover
	 	鼠标离开：onmouseout
	  	获得焦点：onfocus
	  	失去焦点：onblur
	  	键盘按下的时候触发：onkeydown
	  	键盘弹起的时候触发：onkeyup
	  	输入内容的时候触发：oninput
	  	键盘按下事件（不常用）获得的是ascii码:onkeypress

		对于键盘事件，我们关注的是keyCode属性，对于鼠标事件，我们关注的一堆的XY属性。
		
		触发点击事件
			btn2.onclick = function() {
				btn.click();//点击btn2，利用btn.click();触发btn的事件
			}

		注册事件的两种方式
			1.on + 事件名称；注册事件
				box.onclick = null;移除事件
			2.addEventListener('click'，function)；//添加事件
			  removeEventListener('click'，function) ；//移除事件
			  //上面的添加和移除括号里还有第三个参数：一般是false，表示不捕获，使用冒泡
			  //IE678使用以下注册事件
		    3.attachEvent('onclick',function)//添加事件
		      detachEvent('onclick',function)//移除事件

        事件流
        	当HTML元素产生一个事件时，这个事件会在元素节点与根节点之后的路径传播，路径所经过的节点都会收到这个事件，这个传播过程就是DOM事件流

        	事件冒泡：触发子元素，父元素也会被触发。这个事件从原始元素开始一直冒泡到Dom树的最上层
        	一般不用管事件冒泡，但是若是有影响了，就要阻止事件冒泡
        		//正常浏览器：event.stopPropagation();
        		//IE678：event.cancelBubble = true ;
        	事件捕获：触发父元素，子元素也会被触发。从最顶层向下触发
        	事件的三个阶段：捕获阶段、目标阶段：执行当前对象的事件处理程序、冒泡阶段。

    	事件对象
    		为什么要有事件对象？ 在执行事件的时候，需要一些和事件相关的数据
    		每一个事件都有一个对象：在触发事件的时候，会产生一个事件对象event,这个对象中包含了与事件相关的信息
    		如何获取事件对象？
    			function getEvent(event) {
					event = event || window.event ;
    			}
			事件对象的常用属性
				screenX 与 screenY :光标相对于屏幕左上角的水平位置与垂直位置
				clientX 与 clientY :光标相对于客户区左上角的水平位置和垂直位置	
				pageX 与 pageY: 光标相对于网页（文档）左上角的水平位置与垂直位置(推荐使用)
			如何获取到pageX 和 pageY
				function getPage(e) {
					return {
						x:e.pageX || e.clientX + getScroll().left
						y:e.pageY || e.clientY + getScroll().top
					}
				}
				function getScroll() {
					return {
						top:window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
						left:window.pageXOffset || document.documentElement.scrollLeft||document.body.scrollLeft || 0
					}
				}
		 
  	9. Dom 操作样式  style属性
  		1. 标签有style属性，可以设置样式，对象也有对应的style属性。
	    2. 这个style对象里面有很多很多的属性，这些属性都是我们可以写的样式。
	    3. 设置的时候，如果获取的时候带了单位，设置的时候一定也要记得带单位。
	    4. style如果获取的话，只能获取行内样式
	    5. style通常不是用来获取样式的，而是用来设置样式的。
	       var demo = document.getElementById("demo");
	       console.log(demo.style.width);//获取
	       demo.style.width = "400px";//设置
		6.设置不透明度
			style样式里设置：opacity:0.5  filter:alpha(opacity=50)
			js中设置：element.style.opacity = '0.5'
					  element.style.filter = 'alpha(opacity=50)'
	    7.什么时候用style，什么时候用className
		    1. 如果设置的样式比较少，style
		    2. 如果一次要设置很多个样式，className
		    3. 如果设置的这个值，一直在变化，用style
		    4. 	1. 设置不透明，一般要设置两次
		        2. 设置位置，一定要有定位，不要忘了单位
		        3. 设置层级，一定要有定位
        
	10. 延时定时器 和 间歇定时器 的区别
		延时定时器
		var timer = setTimeOut(function(){},1000);
		function: 要执行的代码，不会立即执行，时间到了再执行，只执行一次
		1000：延迟的时间，单位是毫秒
		返回值：timer 定时器的 id
		清除延时定时器：clearTimeOut(timer);

		间歇定时器
		var timer = setInterval(func,1000);
		func:要执行的代码，不会立即执行，和延时定时器一样，唯一的区别就是每隔1000就会执行一次，会执行无数组，直到清除定时器，如果不清除，会一直执行下去 
		1000：间隔的时间
		返回值：定时器的 id
		清除间歇定时器：clearInterval(timer);

		定时器的实质：
		1.设置定时器传的function是由windw来调用的
		2.设置一个定时器，目的是让window每隔一段时间去调用一次这个函数
		3.设置一个而定时器，其实就是开启了一个任务，这个任务就是让window隔一段时间去调用一次这个函数
		4.返回值timer其实就是认为的id，这个id从1开始算的
		5.清除定时器就是把这个任务给清除了
		6.开启一个定时器，仅仅是开启了一个任务，不会等待定时器执行，定时器是不会阻塞代码执行的
		7.在定时器里面不能用this，因为这个this是指向window
   
    11. window 对象  是js里的顶级对象
    	window 对象的常用方法
    		alert(); confirm(); prompt(); console.log();open(); close();
    		document 以及定义的全局变量和全局函数 这些都是window对象常用的属性和方法
    		window.onload  等待页面加载完成，并且等图片也加载完成才开始执行；
    				   		两种情况下使用：当需要获取图片宽高的时候，当script标签写在head标签里的时候
    		window.onresize  事件会在窗口被调整大小的时候触发
    					 	window.onresize = function(){//事件处理程序}
		Bom里常用的对象
			1.window
    		2.location 
	    		location.reload(true);//刷新
				console.log(window.location.hash);//哈希值 其实就是锚点
			    console.log(window.location.host);//服务器 服务器名+端口号
			    console.log(window.location.hostname);//服务器名
			    console.log(window.location.pathname);//路径名
			    console.log(window.location.port);//端口
			    console.log(window.location.protocol);//协议
			    console.log(window.location.search);//参数
    		3.history
				history.back();//后退
				history.go();//前进
			4.document
			5.screen
    		6.navigator

	12. 预解析
		javascript解析器执行js代码的时候，分为两个过程：
		1. 预解析过程
	     * 判断代码有没有语法错误。如果有语法错误，直接就不执行了。
	     * 把变量的声明提前到当前作用域的顶部。只会提升变量的声明，不会提升变量的赋值。（对所有的变量进行标识。方便挖坑。）
	     * 把函数的声明提升到当前作用域的顶部，只提升函数的声明，不会提升函数的调用。
	     * 先提升var，再提升function
		2. 代码执行过程，代码一行一行的往下执行。

	13. 全局变量 与 局部变量
		1.全局变量：在script标签内，在函数外部定义的变量就叫全局变量。
		2.局部变量：在函数内部定义的变量叫局部变量(局部变量只有在自己的function内部才能访问到)
		3.特殊：如果没有使用var声明的变量，这个也是全局变量

	14. 全局作用域 与 函数作用域
		作用域：变量其作用的区域
		全局作用域：在script标签内，在函数外部的区域就叫全局作用域。
		函数作用域：在function内部的区域，就叫函数作用域
		当要使用某一个变量的时候，先从自己的作用域去找这个变量，自己有就用自己的，自己没有，就到全局作用域里面找
		在js里面没有局部作用域，只有全局作用域 和 函数作用域

	15.操作对象属性的两种方式
		点语法：console.log(obj.name) 获取
				obj.name = 'ls' 设置

		中括号：console.log(obj['name']) 获取
				obj['name'] = 'ls' 设置

		有一种情况只能用[]语法
			如果属性名或者说索引名 存在一个变量中的时候，只能用[]方式
			var key = 'name' ;
			obj[key] //只能用这种方式
			obj.key;//不能用这种方式，因为这个时候，用.语法找的不是变量，意思：obj的key属性。

	16.动画的由浅入深
		动画初体验：公式：leader = leader + step ; leader:当前盒子的位置，step：盒子一次跑几像素	
					动画效果要配合定时器，并且一定要清楚定时器；
					当前盒子的位置：可以用offsetLeft去获取
					在最后style设置left距离的时候，box.style.left = leader + 'px' ; px像素一定要加上

		匀速动画：
			function animate(element,target) {
				if(element.timer) {
					clearInterval(element.timer);
				}
				element.timer = setInterval(function(){
					var leader = leader + step ;
					var step = 9 ;
					if(target < leader) {
						step = -step ;
					}
					if(Math.abs(target-leader) >= Math.abs(step)){
						leader = leader + step ;
						element.style.left = leader + 'px' ;
					}else {
						clearInterval(element.timer);
						element.style.left = target + 'px' ;
					}
				},15)
			}

		缓动动画：
			//因为要改很多attr样式，所以可以放在obj中，然后通过for in遍历对象，再把k和value值赋给attr和target
		    //但是这样的话有一个bug，当对象中有一个元素跑到终点的时候，其他的还没跑到就不管了，
		    // 这个bug需要通过定义一个flag假设都跑到终点了,如果leader和目的地不等，那么就返回flag=false，表示还没跑到终点
		    //在for循环结束之后，判断如果flag= true；那么久清除定时器
		    function animate(element,obj,fn) {
				if(element.timer) {
					clearInterval(element.timer);
				}
				element.timer = setInterval(function(){
					var flag = true ;
					for(var k in obj) {
						var attr = k ;
						var target = obj[k] ;
						var leader = parseInt(getStyle(element,attr)) || 0 ;
						var step = (target - leader) / 10 ;
						step = step > 0 ? Math.ceil(step) : Math.floor(step) ;
						leader = leader + step ;
						element.style[attr] = leader + 'px' ;
						if(leader != target) {
							flag = false ;
						}
					}
					if(flag) {
						clearInterval(element.timer);
						fn && fn() ;
					}
				},15)
		    }
		    



	    不透明动画
	    	function animate(element,obj,fn) {
				if(element.timer) {
					clearInterval(element.timer);
				}
				element.timer = setInterval(function(){
					var flag = true ;
					for(var k in obj) {
						if(k === 'opacity') {
							var attr = k ;
							var target = obj[k] ;
							//这里用parseFloat是因为透明度是小数
							var leader = parseFloat(getStyle(element,attr)) || 0 ;
							leader = leader * 1000 ;
							target = target * 1000 ;
							var step = (target - leader) / 10 ;
							step = step > 0 ? Math.ceil(step) : Math.floor(step) ;
							leader = leader + step ;
							element.style[attr] = leader / 1000 ;
							if(leader != target) {
								flag = false ;
							}
						}else {
							var attr = k ;
							var target = obj[k] ;
							var leader = parseInt(getStyle(element,attr)) || 0 ;
							var step = (target - leader) / 10 ;
							step = step > 0 ? Math.ceil(step) : Math.floor(step) ;
							leader = leader + step ;
							element.style[attr] = leader + 'px' ;
							if(leader != target) {
								flag = false ;
							}
						}
						if(flag) {
							clearInterval(element.timer);
							fn && fn() ;
						}
					}
				},15)
			}

		层级动画
			function animate(element,obj,fn) {
				if(element.timer) {
					clearInterval(element.timer);
				}
				element.timer = setInterval(function(){
					var flag = true ;
					for(var k in obj) {
						if(k === 'opacity') {
							var attr = k ;
							var target = obj[k] ;
							var leader = parseFloat(getStyle(element,attr)) || 0 ;
							leader = leader * 1000 ;
							target = target * 1000 ;
							var step = (target - leader) / 10 ;
							step = step > 0 ? Math.ceil(step) : Math.floor(step) ;
							leader = leader + step ;
							element.style[attr] = leader / 1000 ;
							if(leader != target) {
								flag = false ;
							}
						}else if(k === 'zIndex') {
							element.style.zIndex = obj[k] ;
						}
					}else {
						var attr = k ;
						var target = obj[k] ;
						var leader = parseInt(getStyle(element,attr)) || 0 ;
						var step = (target - leader) / 10 ;
						step = step > 0 ? Math.ceil(step) : Math.floor(step) ;
						leader = leader + step ;
						element.style[attr] = leader + 'px' ;
						if(leader != target) {
							flag = false ;
						}
					}
					if(flag) {
						clearInterval(element.timer);
						fn && fn() ;
					}
				},15)
			}
			//获取计算后的样式，让目标元素任意方向的做动画效果
			function getStyle(element,attr) {
				if(window.getComputedStyle) {
					return window.getComputedStyle(element,null)[attr]
				}else {
					return element.currentStyle[attr]
				}
			}

	17.jQuery 常用的方法
		$('li').eq(index) li元素中，索引为index的项
		.odd 奇数项
		.even 偶数项
		$(selector).index();获取当前元素在她所有兄弟元素里面的索引
		$('ul').children('li') 子代选择器 ul的所有li子代
		$('ul').find('li') ul的所有后代li
		siblings('li') 兄弟节点，不包括自身
		parent() 查找父亲
		next() 下一个兄弟
		prev() 上一个兄弟
		.end() 最后
		prevAll() 获取前面的所有兄弟
		nextAll() 获取后面的所有兄弟
		$('div').addClass('name') 添加样式
		$('div').removeClass('name') 移除样式
		$('div').hasClass('name') 判断是否有样式
		$('div').toggleClass('name') 切换样式
		$('#name').val('zs'); 设置值
		$('#name').val() 获取值
		$('div').html() 获取内容
		$('div').html('<span>这是一段内容</span>'); 设置内容
		$('div').text() 获取内容
		$('div').text('<span>这是一段内容</span>') 设置内容
		.height(); 获取  .height(200) 设置
		.width() 同height
		$(selector).scrollTop(100); 设置 $(selector).scrollTop(); 获取
		$(selector).scrollLeft(100); 同scrollTop() 的设置和获取
		$('img').attr('name','value') 设置属性和属性值
			单个：$('img').attr('title','相册')；
			多个：$('img').attr({'title':'haha','alt':'xixi'})
		$('img').attr('name') 获取属性
			注意：1.获取属性，只会获取到第一个元素对应的属性，与css方法一样
		  		  2.获取属性，如果该属性不存在，那么会返回undefined；
	    $('img').removeAttr('name');	
	    	需要移除的属性名，如果传空，那么不会有任何操作，注意，并不是移除所有的属性，区分removeClass
	  				  $('img').removeAttr('title');
	    ## 注意：对于checked、selected、disabled这类boolean类型的属性来说，就要使用prop方法来设置和获取属性了，使用和attr一样，但是获取属性的返回值是true和false；
		    		 //设置属性：$(':checked').prop('checked',true);
		    		 //获取属性：$(':checked').prop('checked');//返回true或者false
		$('btn').css('color','gray'); 操作单个样式
		$('btn').css({'color':'gray','width':'400px','height':'200px'}); 操作多个样式
		$('div').css('color'); 注意：获取样式操作只会返回第一个元素对应的样式值

		.stop();动画抖动使用这个
		.show(speed,callback);不传speed就没有动画效果
		.hide(speed,callback);同show
		.toggle();
		hide与show的方法完全一致。她俩修改的是元素的width、height、opacity。

		.slideUp(speed,callback)滑入 和 .slideDown(speed,callback)滑出，下拉 以及 .slideToggle(speed,callback)切换
		slide修改的是元素的 height 不传speed，默认是normal(400) 有动画效果

		fadeIn() 与 fadeOut() fadeToggle() 淡入淡出切换
		不传speed,默认是normal(400) 有动画效果
		修改的是元素的opacity

		这三种方法修改的是元素的值，都是带数字的，因为带了数字才能渐变动画
		
	18.jQuery 绑定事件
		简单绑定事件-bind绑定事件-delegate事件绑定-on事件绑定
		简单事件绑定：click/mouseenter/mouseleave/scroll  
					  一次只能绑定一个事件
	    bind事件：不支持动态创建出来的元素绑定事件
	    delegate事件：支持动态创建的元素绑定事件，因为绑定在父元素身上，事件冒泡机制，由子元素触发
	    on绑定事件：最现代的方式，兼容zepto(移动端，类似js的一个库)，推荐使用
	    	语法：	$(selector).on(events,selector,data,handler);
			    	events:绑定事件的名称可以是由空格分隔的多个事件(标准事件或者自定义事件)
			    	selector：执行事件的后代元素(可选)，如果没有后代元素，那么事件将有自己执行
			    	data：传递给处理函数的数据，事件触发的时候通过event.data来使用(不常使用)
			    	handler：事件处理函数

		    		$(selector).on('click','span',function(){});//表示给$(selector)绑定代理事件，必须是他内部元素span才能触发这个事件，支持动态绑定:父元素绑定事件

		    		$(selector).on('click',function(){});//表示给$(selector)绑定事件，并由自己触发，不支持动态绑定(不使用代理)；

	19.jQuery的事件解绑
		unbind() 和 undelegate() 一般不用
			$(selector).unbind();//解绑所有的事件
			$(selector).undelegate()//解绑所有的事件
			$(selector).unbind('click');//解绑指定的事件
			$(selector).undelegate('click');//解绑指定的事件
		off() 
			$(selector).off();//解绑匹配元素的所有事件
			$(selector).off('click');//解绑匹配元素的所有click事件
			$(selector).off('click','**');//解绑所有代理**的click事件，元素本身的事件不会被解绑

	20.jQuery 的事件触发
		简单事件触发：$(selector).click();
		trigger方法触发事件
				$(selector).trigger('click');
				triggerHandler 触发事件响应方法，不触发浏览器行为：比如：文本框获得焦点的默认行为
					$(selector).triggerHandler('focus');

	21.jQuery对象 和 Dom对象 的相互转化
		两者之间的方法不能互相调用。jQ对象其实就是Dom对象的包装集(包装Dom对象的集合(伪数组))
		jQ转换成Dom：var $li = $('li'); 第一种中括号的方法：$li[0]; 第二种.get的方法：$li.get(0)
		Dom转jQ：var $obj = $(domObj); $(document).ready(function(){});jQ就是$符号，可以把dom元素添加$符号直接转化

	22.jQ 选择器
		ID选择器：$('#btn');
		类选择器：$('.btn');
		标签选择器：$('div');
		并集选择器：$('p,div,li');
		交集选择器：$('div.redClass');
		层级选择器：子代选择器：$('ul > li')
					后代选择器：$(ul li);
		过滤选择器：这类选择器都带冒号：
	  			  :eq(index);$('li:eq(2)').css('color','red');获取到的li元素中，索引号为2，index是从0开始
	  			  :odd; $('li:odd').css('color','red');获取到的li元素中，索引号为奇数的li元素
	  			  :even；$('li:even').css('color','red');获取到的li元素中，索引号为奇数的li元素
	  			  上面的方法也可以简写成：$('li').eq(2);$('li').even;

    23.链式编程
    	原理：return this 
    	一般情况下，只有设置性操作的时候才能把链式编程延续下去，因为获取性操作的时候会返回获取到的相应的值，无法返回this
    	console.log($('div').width(200).height(200).css('background','red').width());

	24.隐式迭代
		在方法的内部会为匹配到的所有元素进行循环遍历执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们的调用
		如果获取的是多元素的值，大部分情况下会返回第一个元素的值；设置性操作的时候，设置的是所有的元素，获取性操作的时候，获取的是第一个元素的值

	25.each 方法
		有了隐式迭代，为什么还要用each函数遍历
			大部分情况下，是不需要each遍历的，因为jQ的隐式迭代性。但是如果对每个元素进行不同的处理，就要用到each方法了
		作用：遍历jQ对象集合，为每一个匹配的元素执行一个函数
				//参数一表示当前元素在所有匹配元素中的索引号
				//参数二表示当前元素(DOM对象)
				$(selector).each(function(index,element){});
				//也可以下面这样写
				// 第一个参数：表示要遍历的对象
				// 第二个参数：表示回调函数，对遍历对象中的每一项元素都会调用函数
				$.each(selector,function(index,element){}) ;

	26.多库共存
		<script>
			var d = $.noConflict();
			d(function(){
				d('div').width(200).height(200).css('backgroundColor','red');
			})
		</script>

	27.阻止a标签的跳转
		$('a').click(function(e){
			e.preventDefault();//阻止默认跳转
			return false ; //第二种方式
		})

	28.正则表达式：匹配规律规则的表达式
		创建正则的两种方式
			var reg = new RegExp(/\d/);
			var reg = /\d/ ;
		test()作用就是用来检测指定的字符串符不符合正则的规则
			console.log(reg.test('111')) ;
			console.log(/\d/.test('aaa')) ;
		## 预定义类
			\d ：匹配数字 【0 - 9】
			\D ：匹配非数字
			\w ：匹配字符 a - z  A - Z  0 - 9
			\W ：匹配非字符
			\s:匹配不可见字符  匹配空格换行，\t制表符之类:4个空格
			\S:匹配可见字符串
			.:匹配出了\r\n之外的其他字符的
			\\. :匹配.
		## 优先级问题
			|：表示或的意思，优先级最低
			（）：提升优先级的，优先级最高。
		## 字符类
			[abc] :表示一个字符的位置，里面的内容表示这个位置可以出现的字符,这个位置可以出现abc之间的一个字符
			\[abc\]: 表示的是除了abc之外的其他字符 
			\[a-z\]:表示的匹配a-z之间的字符。
		^表示开头
			***注意：如果是在[]里面写的^表示非的意思，比如\[^abc\] ，如果是在[]外面的^表示开头的意思，比如/^a/,表示这个字符串必须以a开头。*** 		
	    	console.log(/[^abc]/.test("addddd"));//匹配除了abc之外其他的字符；结果是true

		$表示结尾
			既以^开头，有以$结尾，表示精确匹配

		## 量词
			\* ：表示0次或者多次   {0,}
			+：表示1次或者多次    {1,}
			? : 表示0次或者1次      {0,1}

			{n}:出现n次
			{n,}出现n次或者n次以上
			{n,m}出现n-m次

		## 括号总结
			():表示优先级最高，通常我们需要提升优先级的时候使用
			[]:表示一个字符的位置，里面的值就是可以出现的内容
			{}:量词，表示出现的次数

		正则的参数：
		g：global全局
		i：ignore忽略大小写
		```javascript
		console.log(str.replace(/ad/gi, "xx"));
		```

		//我们以后写的正则的大多都是^开头，以$结尾，表示精确匹配
		## 练习
		//foot或者boot
    	console.log(/(f|b)oot/.test("abcdeboot"));//这是一种写法，带有小括号的，可以和外面的相连，结果是true；
   		console.log(/[abde]eeee/.test("abde")); //aeeee beeee deeee eeeee；结果是false ；这是中括号的作用

   		 console.log(/^a$/.test("aa"));//false
   		 console.log(/^a$/.test("aaa"));//false
   		 console.log(/^a*$/.test("aab"));//false
   		 console.log(/^a+$/.test("aab"));//false
   		 console.log(/^a{2,3}$/.test("aa"));//true
	     console.log(/^a{2,3}$/.test("aaa"));//true
	     console.log(/^a{2,3}$/.test("aaaa"));//false
	     console.log(/^(chuan){2}$/.test('chuanchuan'));//true

	     var phoneReg = /^0\d{2,3}-\d{7,8}$/;//验证手机号码
		 var nameReg = /^[\u4e00-\u9fa5]{2,6}$/;//验证姓名
		 var qqReg = /^[1-9]\d{4,10}$/;//验证qq
		 var mobileReg = /^(13[0-9]|147|15[0-9]|17[0178]|18[0-9])\d{8}$/;//验证手机号码

		 var str = "   123AD  asadf   asadfasf  adf  ";
	    //1 替换掉字符串中的所有空白
	    console.log(str.replace(/\s/g, ""));//g:global:全局

	    //var jsonStr = '[{"name":"张三",score:8},{"name":"张三",score:90},{"name":"张三",score:81}]';
	    //1. 把所有成绩都修改成100分
	    //console.log(jsonStr.replace(/\d{1,2}/g, "100"));


    29.H5C3 有哪些新增的新特性
    	H5新增的六大标签
    		header nav section aside article footer 
    		作用：和div一样，就是增加了语义性，更有利于seo优化
		H5新增的智能表单控件<type>新属性值
			type = 'email' / 'url' 限制用户输入必须为email或者url类型
			type = 'date' 自动生成一个日期控件(年月日都有)
			type = 'time' 只设置小时
			type = 'week' 有年和多少周
			type = 'month' 有年月
			type = 'number' 只能是数值，另外e也可以
			type = 'search' 搜索框
			type = 'color' 生成一个颜色选择器 (配合change事件，达到换色效果)
			type = 'range' 滑动条，滑动的就是一个比例，具体的值是由min和max属性值对应(配合change事件改变滑动比例)
		H5智能验证表单
			required ==> 验证表单是否为空，必须配合form表单来使用
			pattern ==> 匹配正则，自定义验证表单规则
			invalid ==> 验证失败的时候出发的事件
			dom.setCustomValidity() ==> 自定义弹出的内容，参数：string 自定义内容
				<input type = 'text' pattern = '/[0-9]\d{11}/' id = 'tel' required/>
				tel.addEventListener('invalid',function(){
					this.setCustomValidity = '请输入正确的手机号';
				})
		H5新增的表单属性
			placeholder:占位符
			autofocus：自动获取焦点
						打开页面光标就在文本框里，常见百度搜索，但有兼容性问题，可通过js：dom.focus();解决
			autocomplete：提交一次数据，下次内容自动补全(默认有，可以不写)但必须要有name属性，数据才会真正被提交
			multiple：多选，配合type = 'file' 控件，可实现多选
			form：配合form表单的id值实现关联，使表单在任何位置都可以被提交
		H5智能感应(模糊匹配)
			利用list新属性关联datalist的id值进行模糊匹配：输入一个字，如果列表中有这个字，那么久显示出相关的字
			<input type = 'text' list = 'd_list' />
			<datalist id = 'd_list'>
				<option value="宝马">宝</option>
				<option value="宝骏"></option>
				<option value="宝宝"></option>
			</datalist>
		H5的视频播放
			<video src = '' autoplay loop controls poster = '' ></video>
			<video autoplay loop controls poster = '' width = '400px' height = '400px'>
				<source src = '  .mp4' />
				<source src = '  .ogg' />
				<source src = '  .webm' />
			</video>
			load();重新加载视频
				autoplay：自动播放  loop：循环  controls：控件显现 poster：没播放时浏览的图片
				每个浏览器支持格式不一样，用source来兼容；不需要兼容就直接在video标签内写src属性引入视频。
				从第一个开始找，格式支持，会将对应的视频播放，不支持，会一直找
			实际工作中，打的视频还是用第三方视频播放，一些小的广告类视频、宣传类的手机站、特效(颇多)可以用video
		H5的音频播放
			audio  方法和video一样，只是标签不一样
		H5的网络状态
			window.navigator.onLine：判断当前的网络状态：本质是监听本地连接而不是真正的数据流量。
									 这个属性返回的是布尔值，就是当前的网络设备的状态。
									 因为他不会实时监听，所以我们需要一个事件去通知
			window.addEventListener('online',function(){});从无网到有网的时候触发
			window.addEventListener('offLine',function(){});从有网到无网的时候触发
		H5的地理定位
			window.navigator.geolocation.getCurrentPosition();
			获取地理位置的函数
				有三个参数：第一个是成功的回调函数：接收position对象
														包含用户的地理位置信息：position.coords.latitude纬度
																				position.coords.loogitude经度
							第二个是失败的回调函数：接收error对象
														包含当前的错误信息
							第三个是一个对象，用于适配
				window.navigator.geolocation.getCurrentPosition(function(position){},function(error){},{})
		H5的web存储
			web存储：就是将数据存储到用户的电脑上，这样可以缓解服务器的压力，并且提高用户体验
			web存储的特点：设置、读取方便，容量较大，只能存储字符串，可以将对象 JSON.stringify()编码后存储
			localStorage 和 sessionStorage 以及 传统的document.cookie 
				相同点：都是存储数据，存储在web端，并且都是同源
				不同点：cookie大小4k左右，每次请求会带上cookie，解析复杂，浪费带宽，开发不便，cookie有过期时间。H5				规范提出了解决方案
						sessionStorage和localStorage直接存储在本地，请求不会携带，并且容量比cookie大
						sessionStorage容量约5M，将数据短时间存储在用户电脑里，临时会话。生命周期是关闭浏览器窗口，				直接刷新页面是不会清除的。
									  不支持多窗口的共享，但是可以通过a链接跳转过来的同一个窗口下共享数据
									  运用场景：在一些单页面(SPA)的运用中，进行页面传值的时候比较有用
					    localStorage 容量约20M，将数据永久性的存储在用户的电脑里，除非手动或用代码删除，
					    			 关闭电脑或浏览器都不会清除当前数据，所以经常用来保存一些永久性的数据
					    			 localStorage 和 cookie 都支持 多窗口的数据共享
		    			localStorage和sessionStorage的一些方法详解
		    				存数据：window.localStorage/sessionStorage.setItem(key,value)
		    				取数据：window.localStorage/sessionStorage.getItem(key,value)
		    				删除数据：window.localStorage/sessionStorage.removeItem(key)
		    				整体清除：window.localStorage/sessionStorage.clear()
		    				获取数据的长度：window.localStorage/sessionStorage.length
		    				通过索引值获取键名：window.localStorage/sessionStorage.key(0);
		H5获取元素的新方式(兼容8及以上)
			document.querySelector('');获取的是满足条件的第一个元素
			document.querySelectorAll('');伪数组
			类名操作(移动端常用，兼容10以上)
				Node.classList.add('class');
				Node.classList.remove('class');
				Node.classList.toggle('class');
				Node.classList.contains('class');检测是否存在class
				Node是一个有效的Dom节点，是一个通称
			自定义属性(常用)
				格式：data-* = '' ;
					data-info = '我是自定义属性'
				获取：Node.dataset['info'];获取自定义属性的值
				Node.dataset 是以对象形式存在的，当以 data-my-name = 'zs'设置时，要以驼峰命名获取
					Node.dataset['myName'];
			进度条
			<progress value = '50' min = '0' max = '100'></progress>
				默认值是0-1.但是可以通过min 和 max 去重新设置
			<meter value = '50' min = '0' max = '100' low = '10' high = '80'></meter>
				meter 有low和high的区间值，不在区间就是显示橙色，在区间显示绿色。meter有颜色的切换
			全屏显示
				document.requestFullScreen() 开启全屏显示
				document.cancelFullScreen() 关闭全屏显示
			文件读取
				var file = document.querySelector('input[type="file"]');
				var btn = document.querySelector('button');
				btn.addEventListenner('click',function(argument){
					//1. 将file控件里面的文件提取出来
					var data = file.files[0];
					//2.实例化一个FR对象
					var fr = new FileReader();
					//3. 用这个对象的readAsDataURL（）去读取data文件
					fr.readAsDataURL(data);
					//4. 因为读取文件是一个异步操作 所以当读取完毕之后以事件的形式通知我
					fr.addEventListenner('load',function(){
						//5. 会将读取文件的结果存放的ruslut这个属性下面
						var myResult = fr.result ;

						//创建图片标签
						var img = document.createElement('img');
						img.src = myResult
						document.body.appendChild(img);
					})
				})
			拖拽效果
				1.浏览器中直接拖拽
					//给元素添加draggable=true就可以让元素进行拖拽
					<div draggable="true" class="box"></div>
					<div class="target">将元素拖拽至此</div>
					//拖拽开始
					box.addEventListenner('dragstart',function(){})
					//拖拽持续中
					box.addEventListenner('drag',function(){})
					//拖拽结束
					box.addEventListenner('dragend',function(){})
					// 目标元素身上的事件
					// 拖拽进入
					target.addEventListener('dragenter',function(){})
					// (拖拽悬停)当拖拽元素在当前元素上面的悬上触发
					target.addEventListener('dragover',function(){//阻止默认行为 event.preventDefault()})
					//拖拽离开
					target.addEventListener('dragleave',function(){})
					// 当拖拽元素在当前元素的内部松开鼠标的时候触发
					// drop默认是不允许触发的，需要在dragover的时候阻止浏览器的默认行为
					target.addEventListener('drop',function(){})
				2.拖拽外部文件到浏览器目标元素中
					（1）需要解决图片一旦拖拽到浏览器里面会自动解析，并覆盖当前页面的问题
						// 解决方法 在html里面drop的时候阻止默认事件
						var oHtml = document.documentElement;
						oHtml.addEventListener('drop',function(event){
							// 要想drop事件被成功触发，需要在dragover的时候阻止默认事件
							event.preventDefault();
						})
						oHtml.addEventListener('dragover',function(event){
							event.preventDefault();
						})
						var target = document.querySelector('.target');
						// 给目标元素绑定drop事件
						target.addEventListener('drop',function(event){
							//通过event对象里面的dataTransfer对象拿到里面的files
							var data = event.dataTransfer.files[0];
							//实例化FR对象
							var fr = new FileReader();
							fr.readAsDataURL(data);
							fr.addEventListener('load',function(){
								var myResult = fr.result;
								var img = document.createElement('img');
								img.src = myResult;
								target.innerHTML = '';
								target.appendChild(img);
							})
						})
				3.拖拽外部多媒体文件进行自动解析
					1.如果拖拽的文件是一个多媒体文件，那么在获取到file[0]文件返回data的时候，
					  再次获取data的type值返回给type ==> var type = data.type
				  	2.当获取的文件结果返回给myResult之后，根据用户上传数据里面的type属性进行判断
				  		if(type.indexOf('image/') > -1) {
							target.innerHTML = '';
							var img = document.createElement('img');
							img.src = myResult;
							target.appendChild(img);
							//判断是否是一个视频
				  		}else if(type.indexOf('video/') > -1){
							target.innerHTML = '';
							var video = document.createElement('video');
							video.src = myResult;
							video.autoplay = "autoplay";
							video.controls = "controls";
							target.appendChild(video);
				  		}else {
							alert('请上传正确的文件格式')；
				  		}
	  		自定义视频播放器
	  			方法：load()、play()、pause()
				属性：currentSrc、currentTime、duration
				//当视频在播放的时候，不断的触发事件 timeupdate
				//比例关系：当前视频播放的时间/总的视频时间 = 当前进度条的value/进度条的总长度
				//当前视频播放时间 currentTime  总得视频时间  duration
				//input事件 当表单的值在输入就会触发，输入一次，触发一次

		canvas 标签


		C3的新特性
			问题：浏览器兼容性差，需添加私有前缀；移动端支持优于pc端；应用相对广泛；不断改进中
			应对：坚持渐进增强；考虑用户群体；遵循产品方案；听boss的

			c3选择器
				关系选择器：后代：ul li 
							子代：ul>li
							紧邻：.box+li 选择.box后面的一个li元素
							兄弟：.box~li 选择.box后面的所有li元素

				属性选择器：更多的运用在表单里面
							E[属性名]:包含该属性的所有E元素
							E[属性名 = '值']:是该属性和该值的E元素
							E[属性名 ~= '值']:只要包含该属性和该值的E元素
							E[属性名 ^= '值']:以该值开头的属性名的E元素
							E[属性名 $= '值']:以该值结尾的属性名的E元素
							E[属性名 *= '值']:属性名中任意位置有该值的E元素

				伪类选择器：E:first-child 找到第一个孩子为E的元素
							E:last-child 找到最后一个孩子为E的元素
							E:nth-child(N) 找到第N个孩子为E的元素  N从0开始逐次加1
							nth-child(N)和nth-of-type(N)类似，知识侧重点不一样
							选择器在pc端比较保守，都是IE9以上去兼容

				其他选择器：input:focus{} 选择获取焦点的表单
							input：checked{} 选择被选中的checkbox表单
							input：enabled{} 选择可操作的表单元素
							input：disabled{} 选择不可操作的表单元素
							E：target{} 选择通过锚点跳转的当前E元素
							
			c3伪元素 :before :after
				作用：渲染一个虚拟的标签插入到当前元素的内容的前面或者后面，单标签是没有伪元素的
				总结：1.伪元素是行内元素，需要转块
					  2.伪元素是不存在的，所以不能直接用js去获取(用类去覆盖)
					  3.伪元素是渲染出来的，所以不会增加dom内存
					  4.content一定不能省略，即使里面没有内容也要写一个空字符串
					  5.当伪元素需要hover效果的时候，不能直接hover，需要借助于父级；写法-> 父级：hover：伪元素
					  6.当伪元素配合iconfont去使用的话，需打开iconfont.css拿到content里面对应的值
					  7.字体的用法，可以看阿里图标字体，和有字库，bootstrap里面也有，可以参考看网站使用

		    c3圆角
		    	border-radius:值
		    		1.一个值设置的是四个角的水平和垂直半径
		    		2.每个角可以单独设置，顺序是左上、右上、右下、左下顺时针
		    		3.可以填写 逻辑和padding margin 一样
		    		4.单位支持像素和百分比(参照的是宽高)
		    		5.可以用水平半径/垂直半径，去单独控制半径，并且每个半径都可以单独设置

    		c3阴影
    			box-shadow:值
    				1.水平偏移(正值向右，负值向左)
    				2.垂直偏移(正值向下，负值向上)
    				3.羽化大小(模糊程度)
    				4.阴影尺寸
    				5.颜色，默认是黑色
    				6.内外阴影：默认是外阴影，内阴影是inset
    				7.阴影可以写多个，中间用逗号隔开
    				8.阴影可以简写，但需要注意有些地方需要补0

			c3文字阴影：text-shadow:值
				text-shadow:水平偏移、垂直偏移、羽化大小、颜色

			边框图片：border-image:值
				border-image-source:url('');图片路径
				border-image-slice:26;图片切割，不要带单位，只是数字
				border-image-repeat:round(无瑕疵)/stretch(默认拉伸)/repeat(可能有瑕疵)
				简写：border-image:url('') 26 round ;中间不要有逗号

			背景系列
				1.背景图片的基准点：background-origin:值
					border-box:忽略边框，直接从边框的起始点0 0 平铺
					padding-box:默认值，忽略padding，。。。。。。
					content-box:从内容部分开始平铺，跟padding有关系：会预留出padding的大小

				2.多重背景
					背景图片之间用逗号隔开，可以写多组，最先渲染的图片有可能会遮住后面渲染的图片

				3.控制背景图片的大小：background-size:值
					1.一个值，宽度实现拉伸，高度保持等比例，支持px和百分比(百分比参照的是盒子自身的宽高)
					2.两个值，宽高分别拉伸到对应值，可能变形，支持px和百分比
					3.contain：当图片宽或高在缩放的时候，有一个碰到了盒子边缘，则停止变化(宽高满足一个即可)
					4.cover：在contain的基础上不留白，(宽高都要满足)
					5.自适应背景图片使用百分比去控制宽高，并设置：background-size:100% 100% ;

			盒子内减：box-sizing:值
				1.border-box：会自动减去border和padding的值，会更改盒子模型
				2.content-box：默认值，不会自动减去border和padding的值，会撑大盒子
				3.兼容IE9以上使用，移动端随意
				4.实际工作中，内减配合百分比布局是实现移动端布局的方式之一
					
			渐变(颜色与颜色之间的柔和过渡)
				1.线性渐变：background:linear-gradient(渐变线角度值|to 方位名词，颜色一 止色位，颜色二 止色位)；
					A：默认是180deg，从上到下；0deg是从下到上，90deg从左到右，呈顺时针方向
					B：可使用to 方位名词形式去确定渐变角度，更直观一些
					C：止色的值，可以px和百分比，多用百分，如果后面颜色的值小于前面颜色的值，过渡会很生硬

				2.径向渐变：background:radial-gradient(圆的半径 at 圆心位置 ，颜色一 止色位，颜色二 止色位)
					A：圆的半径分为水平和垂直，不写时，默认水平和垂直各位宽高的一半
					B：圆的半径是一个值，表示正圆，两个不一样的值，椭圆
					C：圆心点的位置默认是在中间，可接受px和百分比以及方位名词(不要加to)
					D：止色的值，可用px和百分比，多用百分比去控制

			私有前缀：兼容低版本的一些高级浏览器或一些特定c3属性需添加私有前缀才起作用，每一条c3属性合理性都需添加			对应浏览器的前缀，以保证兼容。
				-webkit-：谷歌，苹果
				-moz-：火狐
				-ms-：IE
				-o-：o朋
				小细节：一般只需要写一个-webkit-
						直接添加到最前面

			2D转化换：元素在2D平面上实现移动、旋转、缩放、斜切的操作称之为2D转换。
					  transform:值(移动、旋转、缩放、斜切)

			    移动：transform:translate()
			    	  一个值：水平移动，正值向右，负值向左，也可接受百分比
			    	  两个值：水平和垂直
			    	  单个方向移动：translateX()和translateY(正值向下，负值向上)
			    	  移动是移动至某个位置，不是每一次都移动多少像素
			    	  移动不会影响其他元素，类似于相对定位
			    	  可通过盒子的绝对定位配合transform:translate(-50%,-50%)实现没有宽高的盒子水平垂直居中，
			    	  没有宽度的话，盒子最大宽只能是父盒子的一半

		    	旋转：transform:rotate()
		    		  单位是deg，整体发生旋转，包括里面的内容；正值是顺时针旋转，负值反之；中心点可以控制

    		  	控制中心点：transform-origin:值
    		  		   可以是方位名词，可以是px，可以是百分比

	  		    缩放：transform:scale()
	  		    		没有单位，接受小数和数值
	  		    		一个值，等比例整体缩放
	  		    		两个值，宽高分别缩放
	  		    		边框也是会缩放的，想一个方向缩放，另一个方向需要写一个1
	  		    		单方向缩放：scaleX() 和 scaleY() 
	  		    		缩放的中心点也可以被控制

	    		斜切：transform:skew();
	    				单位是deg；
	    				一个值是水平斜切，两个值是水平垂直分别斜切；
	    				斜切的中心点也可被控制，如果是x轴斜切，中心点控制上下，如果是y轴斜切，中心点控制左右

				总结：1.移动、斜切、缩放都可以通过xy去控制某个方向
					  2.中心点可以控制旋转、缩放、斜切
					  3.想要多个2D共存，需采用连写方式
					  		/* 
								错误写法
								transform:rotate(60deg);
								transform:scale(2); */
								/* 正确的写法：多个2D效果共存，采用连写的方式 */
								transform:rotate(60deg) scale(2);
					  4.多场景下使用transform时，需复制前面已经存在的，防止覆盖和冲突
					  		.box {
									transform:translate(-50%,-50%) rotate(0deg);
								}
							.box:hover{
								/* 在多个场景下面，需要复制前面已经存在的2d效果 */
								transform:translate(-50%,-50%) rotate(60deg);
							}
					  5.transform的转换效果顺序保持统一

		    过渡：过渡不是动画，是由css的一种状态到另一种状态中间变换的过程
		    	  transition:过渡属性，持续时间，过渡曲线，过渡延迟时间；
		    	  		哪个属性需要过渡就写什么属性，可以用all代替全部，但是性能较低
		    	  		过渡持续时间，单位可以是s也可以是ms
		    	  		过渡曲线：linear 匀速  ease 逐慢  ease-in 加速  ease-out 减速
		    	  		过渡从何时开始
		    	  		过渡的属性最好写全，display和渐变是不能直接过渡的
		    	  		/* 给谁添加过渡？ 谁的属性发生改变就给谁加过渡 */

	  		3D转换
	  			rotateX();元素在x轴上旋转，正值推倒，负值跪下，没有透视的3D是看不出来效果的
	  			rotateY();元素在y轴上旋转，正值向右(逆时针)，负值向左(顺时针)
	  			backface-visibility:visible|hidden  定义元素背过去是否可见
	  			translateZ：就是在z轴上来回移动，但若没有透视效果时，完全看不出效果
	  				小经验：translateZ和rotate配合使用会产生不一样的3D效果，不同的顺序结果截然不同。
	  						先rotate再translateZ元素是在空间里发生旋转
	  						先translateZ再rotate元素是在直线上发生旋转
				perspective:值；透视值越小，透视效果越强，透视值越大，透视效果越弱(近大远小的效果)
				perspective-origin：值；灭点(透视点，消失点)；
									可以是px，可以是百分比，还可以是方位名词，默认是50%，50%中心点
				transform-style:flat|preserve-3d
								flat是默认值，让子元素不保留其3d位置
								preserve-3d 让子元素保留其3d位置，加在父级身上
							作用：规定被嵌套的元素如何在3d空间中显示
				总结：透视、灭点、transform-style 都是添加在父级身上
				关键：当元素发生3d翻转的时候，整个坐标系也跟着发生翻转
				c3动画：animation：值


									2.动画持续时间，单位是s或者ms：animation-duration
									3.动画的曲线，默认是ease：animation-timing-function
									4.动画从何时开始，默认是0：animation-delay
									5.控制动画执行次数，没有单位，一直执行：infinite；默认是1；
									  animation-iteration-count
									6.控制动画是否逆序播放，默认是normal，逆序：alternate
										animation-direction
									7.控制动画的播放和暂停。默认值：running，暂停：paused
										animation-play-state
									8.动画最后的停留位置，forwards让动画停留在最后一帧
										animation-fill-mode
							ul {
								animation: wufeng 10s linear infinite;
							}
							@keyframes wufeng{
								//多组动画
								0%{
									left: 0;
								}
								100%{
									left: -1200px;
								}
							}
							.box{
								width: 200px;
								height: 200px;
								background-color: green;
								position: absolute;
								left: 0;
								top: 0;
								/* -webkit-animation: donghua 2s linear 0s;
								-moz-animation: donghua 2s linear 0s;
								-ms-animation: donghua 2s linear 0s;
								-o-animation: donghua 2s linear 0s; */
								animation: donghua 2s linear 0s;
							}
							@keyframes donghua {
								from{
									/*在这里写动画语句*/ 
									left: 0;
									width: 200px;
									transform:rotate(0deg);
									background-color: red;
								}
								to{
									width: 600px;
									left: 800px;
									transform:rotate(360deg);
									background-color: blue;
								}
							}

				帧动画：steps(帧数)：逐帧动画素材在网上搜索
						就是让动画执行多少步去执行，steps()里面的数值是总动画面数-1
						在制作精灵图时每个画面的宽度尽量保持一致，并建议在一行摆放
						.bird{
							width: 150px;
							height: 100px;
							background:  url(image/bird.fw.png) 0 0 no-repeat;
							//帧动画
							animation: bird .5s steps(7) infinite,flyer 5s linear infinite;
							position: absolute;
							left: 0;
							top: 0;
						}
						@keyframes bird{
							0%{
								background-position: 0 0;
							}
							100%{
								background-position: -1050px 0;
							}
						}
						@keyframes flyer{
							0%{
								left: -100px;
								top:400px;
							}
							100%{
								top:-400px;
								left: 300px;
							}
						}

				参数值的顺序：关于几个值，除了名字、动画时间、延时有顺序要求，其他随意
				c3定义动画新策略：
					c3底层是c++,而jq的animate用定时器完成，所以c3效率比animate高，若不是功能性动画(轮播图，下拉菜单)不需保证兼容的时候，一律用c3实现，移动端的动画都是用过渡实现(因为手机硬件相对电脑较差，用c3效率高)

			动画库的使用
				1.将对应的animate.css载入到页面中
				2.选择想要的效果，给对应元素加上对应的效果类名
				3.必须加上animate这个类，不然没效果
				4.可参考工具使用中的animate.css网址，找到动画库

			flex布局
				参考阮一峰的个人网站
				必要元素：1.指定一个盒子为伸缩盒子：display：flex
						  2.设置属性来调整此盒的子元素的布局方式
						  3.明确主轴及方向
					  flex布局适应性非常强大，其强大的伸缩性，在响应式开发中可以发挥极大地作用

			Fullpage.js：实现滚屏效果的一款插件


	30.js面向对象
		js面向对象是一种编程思想，也是一种语法规范。他不会提高代码的执行效率，但是提高了代码的可维护性和可扩展性
		面向过程是执行者，那么面向对象就是调度者。面向对象适用于中大型项目以及各个框架中

		
						
		

		

		










 	-->
	<script>
		// 3. 请实现以下函数
  //    add(2,5);    //运行结果为 7
  //    add(2)(5);    //运行结果为 7 
		// function add(x , y) {
		// 	if(arguments.length === 1) {
		// 		return function(z) {
		// 			return x + z ;
		// 		}
		// 	}else {
		// 		return x + y ;
		// 	}
		// }
		// console.log(add(2,5));
		// console.log(add(2)(5));
		
		// 4.编写一个方法，求一个字符串的字节长度
		// function getBytes(str) {
		// 	var len = str.length ;
		// 	var bytes = len ;
		// 	for(var i = 0 ; i < len ; i ++) {
		// 		if(str.charCodeAt(i) > 255) {
		// 			bytes++ ;
		// 		}else {
		// 			return bytes ;
		// 		}
		// 	}
		// }

		// console.log(getBytes('你好,ou')) ;//7

		//5. for (var i = 0; i < 5; i++) {			  
		// 	   	 console.log(i);//0 1 2 3 4 			  
		// 	}

		// for(var i = 0 ; i < 5 ; i ++) {
		// 	setTimeout(function(){
		// 		console.log(i) ; //5个5；因为setTimeout是异步执行，每循环一次结束产生一个事件队列机制，排队打印。
		// 	},1000*i)
		// }

		// for(var i = 0 ; i < 5 ; i ++) {
		// 	(function(i){
		// 		setTimeout(function(){
		// 			console.log(i);
		// 		},1000*i)
		// 	})(i);//0 1 2 3 4 
		// }


		// var a = 1;  
		// function b() {  
		//     var a = 2;
		//     function c() {
		//         console.log(a);
		//     }
		//     return c;
		// }
		// b()();//2  

		// var arr = [11, 2, 3, 1, 99, 80, 66, 555];对数组进行排序
		// console.log(arr.sort(function(a,b){
		// 	return a - b ;
		// }));

		// 将字符串数组按照字符长度从小到大排列
		// var arr = ["a", "bb","dddd","ccc"];
		// console.log(arr.sort(function(a,b){
		// 	return a.length - b.length ;
		// }))


    //将学生数组按照年龄从小到大排列
    // var arr = [
    //     {name:"zs",age:18},
    //     {name:"ls",age:25},
    //     {name:"ww",age:60},
    //     {name:"cc",age:15},
    //     {name:"wq",age:16}
    // ];

    // console.log(arr.sort(function(a,b){
    // 	return a.age - b.age ;
    // }))


    // 数组去重
	// var arr = ["a", "a", "z", "a", "x", "a", "a", "z", "c", "x", "a", "x"];
	// var newArr = [] ;
	// for(var i = 0 ; i < arr.length ; i ++) {
	// 		if(newArr.indexOf(arr[i]) === -1) {
	// 		newArr.push(arr[i]);
	// 	}
	// }
	// console.log(newArr);


	// 求人任意个数的最大值，不准用max，你自己实现一个max
	// function max() {
	// 	console.log(arguments)
	// 	var temp = arguments[0];
	// 	for(var i = 0 ; i < arguments.length ; i ++) {
	// 		if(temp < arguments[i]) {
	// 			temp = arguments[i]
	// 		}
	// 	}
	// 	return temp ;
	// };
	// console.log(max(1,2,3,90,4,45));


	// 获取数组中每个元素出现的次数
	// var arr = ["c", "a", "z", "a", "x", "a", "a", "z", "c", "x", "a", "x"];
	// var obj = {} ;
	// for(var i = 0 ; i < arr.length ; i ++) {
	// 	var temp = arr[i] ;
	// 	if(obj[temp] === undefined) {
	// 		obj[temp] = 1 ;


	// 	}else {
	// 		obj[temp] += 1 ;
	// 	}
	// }
	// console.log(obj) ;


	// var a = function test() {
	// 	var a = 1 ;
	// 	function b() {
	// 		a = 2 ;
	// 		console.log(a) ;//2；a会去找自身作用域中定义的a变量，如果没有，就去上一级找定义的a变量 ，然后把值换了2
	// 	}
	// 	b();
	// 	console.log(a);//这个时候已经把a的值换成了2 
	// }
	// console.log(a);
	// a();//function


	// var a=1;	
	// function test(){ 
	// 	alert(a); //undefined
	// 	var a = 2; 
	// 	alert(a);//2
	// }
	// test();
	// alert(a); //1


	// var str = "abc|bcd|cde|eee";
	// var arr = str.split('|') ;
	// console.log(arr) ;//split 是把字符串切割成数组

	// var str = arr.join('|') ;
	// console.log(str) ;//join是把数组转换成字符串


	 //截取字符串"我爱中华人民共和国"，中的"中华人民"
    // var str = "我爱中华人民共和国";
    // var S = str.substr(2,4) ;
    // console.log(S) ; //substr(开始索引号，截取个数) ;
    // console.log(str) ;//不影响原来的

    //把字符串中所有的o替换成!
       // var str = "abcoefoxyozzopp";
       // // var S = str.replace(/o/g,'!') ;//利用正则全局匹配//g和replace的语法
       // for(var i = 0 ; i < str.length ; i ++) {
       // 	if(str[i] === 'o') {
       // 		str = str.replace('o','!') ;
       // 	}
       // }
       // console.log(str) ;//利用for循环遍历
       // console.log(S)


    //把一个字符串中所有的空格全部去掉
       // var str = "   aa  dfd  dfkjsldf   kdjflkds    ";
       // console.log(str) ;
       // console.log(str.trim(''));//trim方法只会去除首尾的空格，但是中间的空格去不掉，这里用正则表达式
       // console.log(str.replace(/ /g,''));

    //    var str = "   aa  dfd  dfkjsldf   kdjflkds    ";
	   // var arr=str.split("")
	   // var newarr=[];
	   // arr.forEach(function(v,i){
	   //   if(v ===" "){
	   //    return 
	   //  }
	   //  newarr.push(v)
	   // })
	   // var a = newarr.join('')
	   // console.log(a)

	   // var str = "   aa  dfd  dfkjsldf   kdjflkds    ";
	   // var s='';
	   // for( var i = 0; i < str.length; i++ ){
	   //  if( str[i] !== " "){
	   //    s += str[i]
	   //  }
	   // }
	   // console.log(s)

	  // 不使用reverse翻转字符串
    //   var str = 'hello' ;
    //   var arr = []
    //   for(var i = str.length -1 ; i >= 0 ; i--) {
		  // arr.push(str[i]) ;
    //   }
    //   console.log(arr.join('')) ;

    //混入式继承
    // var obj = {} ;
    // var a = {
    // 	name : 'zs',
    // 	age : 18,
    // 	sex : 'man'
    // }
    // var b = {
    // 	name : 'ls',
    // 	run : function(){}
    // }
    // obj.extend = function(c) {
    // 	for(var k in c) {
    // 		obj[k] = c[k]
    // 	}
    // }
    // obj.extend({
    // 	html:function(){},
    // 	attr:function(){}
    // })
    // obj.extend(a);
    // obj.extend(b);
    // console.log(obj);

    //原型式继承：对象继承自原型对象，对象想要使用某些公共的属性和方法，只需要将这些属性和方法添加到原型中
    		//给原型添加成员的方式
     			//1.利用对象的动态性(可以在任何情况下，给对象添加属性和方法)
     				// function Person() {
     				// 	this.name = 'zs'
     				// }
     				// var p1 = new Person();
     				// console.log(p1.name);
     				// Person.prototype.legs = 2 ;
     				// Person.prototype.run = function(){};
     				// console.log(p1.legs);
				// 2.利用覆盖原型对象的方式
					// function Person(){};
					// Person.prototype = {
					// 	constructor:Person,
					// 	name:'zs',
					// 	age:20,
					// 	say:function(){}
					// }
					// var p2 = new Person();
					// console.log(p2.name);
				// 3 利用混入式继承来添加成员
					// function Person(){};
					// Person.prototype.extend = function(obj){
					// 	for(var k in obj){
					// 		this[k] = obj[k];
					// 	}
					// }
					// Person.prototype.extend({
					// 	coding:function(){console.log('123')},
					// 	html:function(){},
					// 	legs:2
					// })
					// var p3 = new Person();
					// console.log(p3.coding());

	//经典继承
		// Object.create方法的特点：
				// 1 会创建一个新对象
				// 2 新创建的对象会继承自 参数对象
				// 3 会把创建的新对象放回
		// var obj = {
		// 	name: 'zs',
		// 	age: 18 ,
		// 	say: function(){}
		// }
		// var newObj = Object.create(obj);
		// console.log(newObj)
		// console.log(newObj.__proto__ === obj)









	</script>
</body>
</html>