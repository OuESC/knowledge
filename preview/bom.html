<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:bom</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<p>bom是浏览器对象模型，提供了一套操作浏览器功能的工具。他的组成就是window对象和dom对象。可以做一些动画操作：初始动画、轮播图动画效果、缓动动画、手风琴、360开机动画、腾讯固定导航、旋转木马、瀑布流、天使飞、放大镜、拖拽、弹出框、弹幕、获取自身宽高度、滚动的宽高、可视的宽高、注册事件的两种方式等等。</p>
<h2 id="1-window-">1.Window对象</h2>
<pre><code>1. window对象是js里面的顶级对象
2. 我们经常使用到的东西其实都是window的。alert() console.log() prompt() document这些都是window对象的属性或者方法
3. window对象太常用了，所以我们可以省略不写。
4. 我们平时定义的全局变量和全局函数其实都是window的属性和方法。    
</code></pre><h2 id="2-window-onload">2.Window.onload</h2>
<pre><code>什么时候执行？
    等待页面加载完成，并且等图片也加载完成之后才开始执行
什么时候用window.onload ？
    1.如果需要获取图片的高度和宽度的时候，需要使用
    2.当script标签写在head标签里面的时候
</code></pre><h2 id="3-">3.定时器</h2>
<pre><code>#延时定时器

    设置延时定时器：var timer = setTimeOut(fun,delay) ;
    //function:要执行的代码，不会立即执行，时间到了再执行。只执行一次；
    //delay：延迟的事件，单位是毫秒

    返回值：定时器的id

    清除延时定时器：clearTimeOut(timer) ;

#间歇定时器

    设置间歇定时器：var timer = setInterval(fun,delay) ;
    //function:要执行的代码，不会立即执行，和延时定时器一样，唯一的区别就是每个delay都会执行一次，会执行无数组，直到清除定时器，如果不清楚，会一直执行下去。
    //delay：间隔的时间

    返回值：定时器的id

    清除间歇定时器：clearInterval(timer) ;


#定时器的实质：

1. 设置定时器的时候，传的function是由window来调用的。
2. 设置一个定时器，目的是让window每隔一段时间去调用一次这个函数。
3. 设置一个定时器，其实就是开启了一个任务，这个任务就是让window隔一段事件去调用一次这个函数。
4. 返回值timer返回其实就是任务的id，这个id从1开始算的
5. 清除定时器就是把对应的那个任务给清除了。
6. 开启一个定时器，仅仅是开启了一个任务，不会等待定时器执行。定时器是不会阻塞代码的执行的。




***在定时器里面不能用this 因为这个this指的是window***
</code></pre><h2 id="4-offset-">4.offset家族</h2>
<pre><code># offsetWidth 与 offsetHeight 
offsetWidth：获取的是真实宽度，结果是数值类型，可以直接参与运算，是只读属性：只能获取，不能设置
             offsetWidth：包含了width+padding+border；不包含margin
offsetHeight：同width，但是是高度


# offsetLeft 与 offsetTop 
offsetLeft：获取的是相对于offsetParent的真实距离；值是数值类型，可直接参与运算，只读属性，只能获取，不能设置
offsetTop：同left，但是是高度

注意：获取盒子的宽高左右用style属性也可以，但是style.width获取的是100px这样的字符串，参与运算还需要parseInt，style        属性只能获取行内样式，另外，style属性可以获取也可以设置。

      以后设置就用style，获取就用offset家族；


# offsetParent 与 parentNode
offsetParent：找的是最近的有定位的父元素(干爹)；
parentNode：找的是直接父元素(亲爹) ；


## scroll家族

scroll家族用来获取盒子内容的大小和位置
offset家族用来获取盒子自身的大小和位置

scroll家族有：scrollWidth、scrollHeight、scrollLeft、scrollTop

scrollWidth 与 scrollHeight 
是盒子内容的真是宽度和高度。与盒子的大小无关，仅仅与盒子的内容有关系

scrollLeft 与 scrollTop
一个是盒子内容被滚动条卷去的头部的高度，一个是盒子内容被滚动条卷去的左侧的宽度


onscroll 事件
对于有滚动条的盒子，可以使用onscroll注册滚动事件，每滚动一像素，就会触发该事件

获取页面滚动坐标有兼容性，封装函数
function scroll() {
    return {
        top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 ;
        left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0 ;
    }
}
console.log(scroll().top) ;
console.log(scroll().left) ;



## client 家族
offset家族是用来获取元素自身的大小和位置
scroll家族是用来获取元素内容的大小和位置
client家族是用来获取元素可视区域的大小


clientWidth 与 clientHeight 
偏移：offsetWidth: width + padding + border 
卷曲：scrollWidth: width + padding 不包含border，内容的大小
可视：clientWidth: width + padding 不包含border
如果内容没有超出盒子范围，那么clientWidth 与 scrollWidth 相同


clientLeft 与 clientTop 完全没有用，他们就是border-top 与 border-left ；
但是如果有滚动条，还会包含滚动条的宽度


获取页面可视宽高的兼容性封装
function client() {
    return {
        width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0 ,
        height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0 
    }
}


## onresize 事件
onresize 事件会在窗口被调整大小的时候发生。
window.onresize = function() {//事件处理程序} ；
</code></pre><h2 id="5-">5.动画初体验</h2>
<pre><code>公式：leader = leader + step ; leader:当前盒子的位置，step：盒子一次跑几像素
动画效果要配合定时器，并且要清除定时器；当前盒子的位置可以用offsetLeft去获取。在最后box.style.left = leader + &#39;px&#39; ; px像素一定要加上；
</code></pre><h2 id="6-">6.匀速动画的封装</h2>
<pre><code>function animate(element,target) {
    if(element.timer) {
        clearInterval(element.timer) ;
    };

    element.timer = setInterval(function(){
        var leader = element.offsetLeft ;
        step = 9 ;
        //目标位置小于自身所在的位置，就让step为负值
        if(target &lt; leader) {
            step = -step ;
        };

        //如果步数是9的话，永远都跑不到重点
        //如果到达终点的距离已经小于一步了，就不跑了，因为你再跑就过了。
        //先判断如果距离大于等于一步的距离，就用公式
        //如果距离小于一步了，在清除定时器的时候，再把剩下的target距离加上
        if(Math.abs(target-leader) &gt;= Math.abs(step)) {
            leader = leader + step ;
            element.style.left = leader + &#39;px&#39; ;
        }else {
            clearInterval(element.timer) ;
            element.style.left = target + &#39;px&#39; ;
        }
    },15) ;
}
</code></pre><h2 id="7-">7.缓动动画封装</h2>
<pre><code>function animate(element,obj,fn) {
    if(element.timer) {
        clearInterval(element.timer) ;
    };

    element.timer = setInterval(function(){
    //因为要改很多attr样式，所以可以放在obj中，然后通过for in遍历对象，再把k和value值赋给attr和target
    //但是这样的话有一个bug，当对象中有一个元素跑到终点的时候，其他的还没跑到就不管了，
    // 这个bug需要通过定义一个flag假设都跑到终点了,如果leader和目的地不等，那么就返回flag=false，表示还没跑到终点
    //在for循环结束之后，判断如果flag= true；那么久清除定时器
        var flag = true ;//假设都跑到终点了
        for(var k in obj) {
            var attr = k ;
            var target = obj[k] ;
            var leader = parseInt(getStyle(element,attr)) || 0 ;
            var step = (target = leader) / 10
            step = step &gt; 0 ? Math.ceil(step) : Math.floor(step) ;
            leader = leader + step ;
            element.style[attr] = leader + &#39;px&#39; ;

            if(leader != target) {
                flag = false ;
            }
        }
        if(flag) {
            clearInterval(element.timer) ;
            fn &amp;&amp; fn() ;
        }
    },15) ;
}

function getStyle(element,attr) {
    if(window.getComputedStyle) {
        return window.getComputedStyle(element,null) [attr] ;
    }else{
        return element.currentStyle[attr] ;
    }
}
</code></pre><h2 id="8-">8.##不透明动画的封装</h2>
<pre><code>function animate(element,obj,fn) {
    if(element.timer) {
        clearInterval(element.timer) ;
    }
    element.timer = setInterval(function(){
        var flag = true ;
        for(var k in obj ) {
        //判断设置的属性是不是透明度
            if(k == &#39;opacity&#39;) {
                var attr = k ; 
                var target = obj[k] ;
                //这里用parseFloat是因为透明度是小数
                var leader = parseFloat(getStyle(element,attr)) || 0 ;

                //把当前位置和目标都同时放大1000倍
                leader = leader * 1000 ;
                target = target * 1000 ;

                var step = (target - leader) / 10 ;
                step = step &gt; 0 ? Math.ceil(step) : Math.floor(step) ;
                leader = leader + step ;
                element.style[attr] = leader / 1000 ;
                if(leader != target) {
                    flag = false ;
                }
            }else {
                var attr = k ;
                var target = obj[k] ;
                var leader = parseInt(getStyle(element,attr)) || 0 ;
                var step = (target - leader) / 10 ;
                step = step &gt; 0 ? Math.ceil(step) : Math.floor(step) ;
                leader = leader + step ;
                element.style[attr] = leader + &#39;px&#39; ;
                if(leader != target) {
                    flag = false ;
                }
            }
            if(flag) {
                clearInterval(element.timer) ;
                fn &amp;&amp; fn() ;
            }
        }
    },15) ;
}
</code></pre><h2 id="9-">9.层级动画的封装</h2>
<pre><code>function animate(element,obj,fn) {
    if(element.timer) {
        clearInterval(element.timer) ;
    };
    element.timer = setInterval(function(){
        var flag = true ;
        for(var k in obj) {
            if(k === &#39;opacity&#39;) {
                var attr = k ; 
                var target = obj[k] ;
                var leader = parseFloat(getStyle(element,attr)) || 0 ;
                target = target * 1000 ;
                leader = leader * 1000 ;
                var step = (target - leader) / 10 ;
                step = step &gt; 0 ? Math.ceil(step) : Math.floor(step) ;
                leader = leader + step ;
                element.style[attr] = leader / 1000 ;
                if(leader != target) {
                    flag = false ;
                };

            }else if (k === &#39;zIndex&#39;) {
                element.style.zIndex = obj[k] ;
            }else {
                var attr = k ;
                var target = obj[k] ;
                var leader = parseInt(getStyle(element,attr)) || 0 ;
                var step = (target - leader) / 10 ;
                step = step &gt; 0 ? Math.ceil(step) : Math.floor(step) ;
                leader = leader + step ;
                element.style[attr] = leader + &#39;px&#39; ;
                if(leader != target) {
                    flag = false ;
                }
            }
        }
        if(flag) {
            clearInterval(element.timer) ;
            fn &amp;&amp; fn() ;
        }
    },15) ;
}
</code></pre><h2 id="10-">10.获取计算后的样式</h2>
<pre><code>function getStyle(element,attr) {
    if(window.getComputedStyle) {
        //现代浏览器
        return window.getComputedStyle(element,null)[attr] ;
    }else{
        //IE678
        return element.currentStyle[attr] ;
    }
}
 console.log(window.getComputedStyle(box,null).top);
 console.log(box.currentStyle.width);
</code></pre><h2 id="11-">11.触发点击事件</h2>
<pre><code>btn2.onclick = function() {
    btn1.click() ;//点击btn2，利用btn1.click();触发btn1的事件；
}
</code></pre><h2 id="12-">12.事件对象</h2>
<pre><code>    1.为什么要有事件对象？--&gt; 在执行事件的时候，需要一些和事件相关的数据。比如：让小精灵飞到鼠标移动的位置。

    2.其实，每一个事件都有一个对象：在触发事件的时候，会产生一个事件对象event,这个对象中包含了与事件相关的信息
    3.如何获取事件对象？
            function getEvent(event) {
                    event =  event || window.event ;
            }
    4.事件对象的常用属性
            screenX 与 screenY :光标相对于屏幕左上角的水平位置与垂直位置
            clientX 与 clientY :光标相对于客户区左上角的水平位置和垂直位置    
            pageX 与 pageY: 光标相对于网页（文档）左上角的水平位置与垂直位置(推荐使用)
    5.如何获取到pageX 和 PageY ？
        function getPage(e) {
                return {
                        x: e.pageX || e.clientX + getScroll().left ;
                        y: e.pageY || e.clientY + getScroll().top ;
                };
        }         
        function getScroll() {
                return {
                        top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 ,
                        left:window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0 
                };
        };
</code></pre><h2 id="13-">13.注册事件的两种方式</h2>
<pre><code>1.on + 事件名称；注册事件
    box.onclick = null;移除事件
2.addEventListener(&#39;click&#39;，function)；//添加事件
  removeEventListener(&#39;click&#39;，function) ；//移除事件
  //上面的添加和移除括号里还有第三个参数：一般是false，表示不捕获，使用冒泡
  //IE678使用以下注册事件
  3.attachEvent(&#39;onclick&#39;,function)//添加事件
    detachEvent(&#39;onclick&#39;,function)//移除事件        
</code></pre><h2 id="14-">14.事件流</h2>
<pre><code>当HTML元素产生一个事件时，这个事件会在元素节点与根节点之后的路径传播，路径所经过的节点都会收到这个事件，这个传播过程就是DOM事件流
DOM事件流分为冒泡事件流和捕获事件流

事件冒泡：当触发了子元素后，父元素对应的事件也会被触发，这个事件从原始元素开始一直冒泡到DOM树的最上层

注意：# 事件冒泡
子元素触发事件的时候，所有的父元素都会一次触发。兄弟元素和子元素都不会触发。

通常情况，事件冒泡对于我们来说是没有问题的，我们直接不管就行了，但是如果当事件冒泡给我们带来影响的时候，我们需要阻止事件冒泡。

阻止事件冒泡
//正常浏览器：event.stopPropagation() ;
//IE678：event.cancelBubble = true ;

事件的三个阶段：
捕获阶段、目标阶段：执行当前对象的事件处理程序、冒泡阶段
</code></pre><h2 id="15-">15.常用的鼠标事件与键盘事件</h2>
<pre><code>鼠标事件：onmousedown/onmouseup/onclick/ondbclick/onmouseover/onmousemove/onmouseout/onkeydown/onkeyup/onfocus/onblur

onkeydown：键盘按下事件：获取的是键盘码

onkeyup：键盘弹起事件    

onkeypress:键盘按下事件（不常用）获得的是ascii码



对于键盘事件，我们关注的是keyCode属性，对于鼠标事件，我们关注的一堆的XY属性。
</code></pre><h2 id="16-">16.正则表达式：匹配规律规则的表达式</h2>
<pre><code>今天学习的目标：正则表达式有一定难度，不要求非常的熟练，现阶段只要能用正则表达式完成表单校验即可，后面的框架课也会涉及到一些，将来需要使用到正则的时候，网上一搜一大堆。

## 创建正则的两种方式
    构造函数的方式:var reg = new RegExp(/\d/) ;
    字面量：var reg = /\d/ ;

## test()的作用就是用来测试指定的字符串符不符合正则的规则
    console.log(reg.test(&#39;111&#39;)) ;
    console.log(/\d/.test(&#39;aaa&#39;)) ;

## 预定义类
\d ：匹配数字 【0 - 9】
\D ：匹配非数字
\w ：匹配字符 a - z  A - Z  0 - 9
\W ：匹配非字符
\s:匹配不可见字符  匹配空格换行，\t制表符之类:4个空格
\S:匹配可见字符串
.:匹配出了\r\n之外的其他字符的
\\. :匹配.

## 优先级问题
|：表示或的意思，优先级最低
（）：提升优先级的，优先级最高。

## 字符类
[abc] :表示一个字符的位置，里面的内容表示这个位置可以出现的字符,这个位置可以出现abc之间的一个字符
\[abc\]: 表示的是除了abc之外的其他字符 
\[a-z\]:表示的匹配a-z之间的字符。

# 正则进阶
## 边界
    ^表示开头
    ***注意：如果是在[]里面写的^表示非的意思，比如\[^abc\] ，如果是在[]外面的^表示开头的意思，比如/^a/,表示这个字符串必须以a开头。*** 

    console.log(/[^abc]/.test(&quot;addddd&quot;));//匹配除了abc之外其他的字符；结果是true

    $表示结尾
    既以^开头，有以$结尾，表示精确匹配
    ```javascript
    console.log(/^chuan$/.test(&quot;chuan&quot;));//true
    console.log(/^chuan$/.test(&quot;chuang&quot;));//false
    console.log(/^chuan$/.test(&quot;dachuan&quot;));//false
    console.log(/^chuan$/.test(&quot;chuanchuan&quot;));//false
</code></pre><pre><code>
    ## 量词
        \* ：表示0次或者多次   {0,}
        +：表示1次或者多次    {1,}
        ? : 表示0次或者1次      {0,1}

        {n}:出现n次
        {n,}出现n次或者n次以上
        {n,m}出现n-m次


    ## 括号总结
        ():表示优先级最高，通常我们需要提升优先级的时候使用
        []:表示一个字符的位置，里面的值就是可以出现的内容
        {}:量词，表示出现的次数


    正则的参数：
        g：global全局
        i：ignore忽略大小写
        ```javascript
        console.log(str.replace(/ad/gi, &quot;xx&quot;));
</code></pre><pre><code>//我们以后写的正则的大多都是^开头，以$结尾，表示精确匹配

## 练习
    //foot或者boot
    console.log(/(f|b)oot/.test(&quot;abcdeboot&quot;));//这是一种写法，带有小括号的，可以和外面的相连，结果是true；
       console.log(/[abde]eeee/.test(&quot;abde&quot;)); //aeeee beeee deeee eeeee；结果是false ；这是中括号的作用

        console.log(/^a$/.test(&quot;aa&quot;));//false
        console.log(/^a$/.test(&quot;aaa&quot;));//false
        console.log(/^a*$/.test(&quot;aab&quot;));//false
        console.log(/^a+$/.test(&quot;aab&quot;));//false
        console.log(/^a{2,3}$/.test(&quot;aa&quot;));//true
     console.log(/^a{2,3}$/.test(&quot;aaa&quot;));//true
     console.log(/^a{2,3}$/.test(&quot;aaaa&quot;));//false
     console.log(/^(chuan){2}$/.test(&#39;chuanchuan&#39;));//true

     var phoneReg = /^0\d{2,3}-\d{7,8}$/;//验证手机号码
     var nameReg = /^[\u4e00-\u9fa5]{2,6}$/;//验证姓名
     var qqReg = /^[1-9]\d{4,10}$/;//验证qq
     var mobileReg = /^(13[0-9]|147|15[0-9]|17[0178]|18[0-9])\d{8}$/;//验证手机号码

     var str = &quot;   123AD  asadf   asadfasf  adf  &quot;;
    //1 替换掉字符串中的所有空白
    console.log(str.replace(/\s/g, &quot;&quot;));//g:global:全局

    //var jsonStr = &#39;[{&quot;name&quot;:&quot;张三&quot;,score:8},{&quot;name&quot;:&quot;张三&quot;,score:90},{&quot;name&quot;:&quot;张三&quot;,score:81}]&#39;;
    //1. 把所有成绩都修改成100分
    //console.log(jsonStr.replace(/\d{1,2}/g, &quot;100&quot;));
</code></pre><p>.## location 对象
    location.reload(true);//刷新
    console.log(window.location.hash);//哈希值 其实就是锚点
    console.log(window.location.host);//服务器 服务器名+端口号
    console.log(window.location.hostname);//服务器名
    console.log(window.location.pathname);//路径名
    console.log(window.location.port);//端口
    console.log(window.location.protocol);//协议
    console.log(window.location.search);//参数</p>
<p>.## history 对象
    history.back();//后退
    history.go();//前进</p>
<h2 id="-">案例分析</h2>
<pre><code>1.机械表：封装函数获取当前时间，利用定时器。并且小时里要加上分钟/60,分钟加上秒数/60，秒数加上毫秒数/1000                      ;这样指针的位置才好

2.短信验证：设定定时器timer，num值，利用value，点击按钮禁用按钮，判断当num==0的时候，回到初始value，按钮不禁用 ！

3.轮播图：点击小方块的简单轮播---&gt;{css样式：一个大盒子，里面是一个inner盒子包裹着ul(img)和div(span下面的小方块)                                                两个盒子

                                    js：获取一张图片的大小，不是用img，而是用inner最大的这一层去获取图片的大小；利      用小方块的索引，在移动ul的时候，目标移动距离就是一张图片的大小*索引
                                        var idx = this.index;
                                        var target = - imgWidth * idx;//为什么要给负号，因为要往左移
                                        animate(ul, target);
                                    }

           箭头左右焦点图轮播---&gt;{css样式：一个大盒子，里面包裹两个兄弟盒子：一个盒子包裹ul图片，另一个包裹span箭头

                                    js：先定义一个pic记录需要跑出去的图片的张数；在css样式中要把第一张图片复制一份放      到最后一张真图片的后面，在js中点击右箭头如果是最后一张图片的时候瞬间换成第一      张真图片。让出去的张数++；目标距离：- pic * 一张图片的大小；

                                     //点击左箭头判断是否是真图片，如果是真图片，瞬间换成假图片
                                    if(pic == 0) {
                                        ul.style.left = - (lis.length - 1) * imgWidth + &quot;px&quot;;//把ul给拽回来
                                        pic = lis.length - 1;//保证同步
                                    }

                                    pic--;
                                    var target = -pic * imgWidth;
                                    animate(ul, target);
                                  }


           完整版轮播图---&gt;{css样式：一个大盒子里面包裹着两个盒子；第一个盒子里有ul包裹图片，以及ol，ol里面的小方块                             由js动态生成，第二个盒子包裹的是两个span箭头

                                js：1.必须先根据ullis的长度动态生成ol里面的li，让第一个ollis高亮；再动态生成一张假图片         ，因为先生成假图片的话，ol里面的li就多了；
                                     2.开始点击小方块ollis简单轮播，小方块排他高亮；利用index
                                     3.鼠标经过盒子，显示箭头，离开盒子隐藏
                                     4.箭头的焦点轮播：先定义一个pic记录需要出去的图片的张数，点击右箭头，判断若是最后    一张假图片，瞬间换成第一张真图片：pic = 0 ；ul.style.left = &#39;0px&#39;                     ;点击左箭头判断是不是第一张图片，瞬间换成最后一张，pic= ullis.length - 1 ;         ul.style.left = -pic * imgWidth + &#39;px&#39; ;
                                     5.自动轮播：重新先定义一个timer，设置timer = setInterval(function(){
                                         rightArr.onclick() ;//触发右箭头的点击事件；
                                     })
                                     6.修改bug：a：鼠标经过盒子的时候，清除右箭头的触发事件，也就是清除定时器，离开盒子                 的时候，再次开启定时器；在3里面去写代码；
                                                 b：同步小方块：先定义一个square= 0 ；记录小方块的索引；在左右箭头点击的
                                                     时候，下面的小方块也要同步:右箭头的时候
                                                     square++;
                                                     if(square == ollis.length ){
                                                         square = 0 ;
                                                     }
                                                     for(var i = 0 ; i &lt; olLis.length ; i ++) {
                                                         ollis[i].className = &#39;&#39; ;
                                                     }
                                                     ollis[square].className = &#39;current&#39; ;
                                                   }
                                                   左箭头的时候
                                                   square--;
                                                   if(square == -1) {
                                                       square = ollis.length - 1 ;
                                                   }
                                                   for(var i = 0 ; i &lt; ollis.length ; i ++) {
                                                       ollis[i].className = &#39;&#39; ;
                                                   }
                                                   ollis[square].className = &#39;current&#39; ;
                                                   这两端代码分别是在点击左右箭头的时候去写 ；

                                               c：点击小方块的时候，也要做同步：在2里面去写代码：
                                                   square = pic = this.index



          完美版轮播图(加了节流阀) --&gt; 代码如下
                  for(var i = 0 ; i &lt; ulLis.length ; i ++) {
                      var li = document.createElement(&#39;li&#39;) ;
                      ol.appendChild(li) ;
                      li.innerHTML = i + 1 ;
                  }
                  olLis = ol.children ;
                  olLis[0].className = &#39;current&#39; ;
                  var cloneLi = ulLis[0].cloneNode(true) ;
                  ul.appendChild(cloneLi) ;
                  for(var i = 0 ; i &lt; olLis.length ; i ++) {
                      olLis[i].index = i ;
                      olLis[i].onclick = function() {
                          for(var i = 0 ; i &lt; olLis.length ; i ++) {
                              olLis[i].className = &#39;&#39; ;
                          }
                          this.className = &#39;current&#39; ;
                          if(pic == ulLis.length - 1) {
                              pic = 0 ;
                              ul.style.left = 0 ;
                          }
                          var target = - this.index * imgWidth ;
                          animate(ul,{&#39;left&#39;:target}) ;
                          pic = square = this.index ;
                      }
                  }
                  box.onmouseover = function() {
                      arr.style.display = &#39;block&#39; ;
                      clearInterval(timer) ;
                  }
                  box.onmouseout = function() {
                      arr.style.display = &#39;none&#39; ;
                      timer = setInterval(function(){
                          rightArr.click() ;
                      },1000);
                  }
                  rightArr.onclick = function() {
                      if(flag) {
                          flag = false ;
                          if(pic == ulLis.length - 1) {
                              pic = 0 ; 
                              ul.style.left = 0 ;
                          }
                          pic++ ;
                          var target = -pic * imgWidth ;
                          animate(ul,{&#39;left&#39;:target},function(){
                              flag = true ;
                          });
                          square++ ;
                          if(square == olLis.length) {
                              square = 0 ;
                          }
                          for(var i = 0 ; i &lt; olLis.length ; i ++) {
                              olLis[i].className = &#39;&#39; ;
                          }
                          olLis[square].className = &#39;current&#39; ;
                      }
                  }
                  leftArr.onclick = function() {
                      if(flag) {
                          flag = false ;
                          if(pic == 0) {
                              pic = ulLis.length - 1 ;
                              ul.style.left = -pic * imgWidth + &#39;px&#39; ;
                          }
                          pic--;
                          var target = -pic*imgWidth ;
                          animate(ul,{&#39;left&#39;:target},function(){
                              flag = true ;
                          });
                          square-- ;
                          if(square == -1) {
                              square = olLis.length - 1 ;
                          }
                          for(var i = 0 ; i &lt; olLis.length ; i ++) {
                              olLis[i].className = &#39;&#39; ;
                          }
                          olLis[square].className = &#39;current&#39; ;
                      }
                  }
                  timer = setInterval(function(){
                      rightArr.click() ;
                  },1000) ;

4.筋斗云导航栏：{css样式：一个大盒子包裹着一个span和一个ul，大盒子和ul都要设置相对定位；
                js:封装一个简单的缓动动画，在鼠标经过的时候，target就是当前li的offsetLeft值；
                    鼠标离开的时候，target就是最先定义的lastPosition的初始值，让他回到最开始的地方；
                    给每个li注册点击事件的时候，让他的lastPosition等于当前点击的li的offsetLeft值
                封装的缓动动画：
                function animate(element,target) {
                    if(element.timer) {
                        clearInterval(element.timer) ;
                    };
                    element.timer = setInterval(function(){
                        var leader = element.offsetLeft ;
                        var step = (target - leader) / 10 ;
                        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step) ;
                        leader = leader + step ;
                        element.style.left = leader + &#39;px&#39; ;
                        if(leader == target) {
                            clearInterval(element.timer) ;
                        }
                    },15) ;
                }

            }



5.360开机动画：{css:一个大盒子嵌套一个span关闭标签和两个兄弟盒子，两个兄弟盒子分别包裹着头部和底部的图片
                js:封装一个参数是element，obj，fn的缓动动画，点击关闭按钮的时候，底部图片的高度为0 ，然后再回调animate，使头部的宽度为0；
                }                                  


6.定位版本的手风琴：思路：1.box和li的大小都是1200相等的；box相对定位，li绝对定位；box设置溢出隐藏属性
                          2.给每个li设置背景图片，再利用style.left设置初始left值；保存每个li的索引=i；
                          3.给每个li注册鼠标经过事件，有排他，所以再遍历一次lis，判断每个li的索引在小于等于当前点击的li的this.index的时候，利用animate()；让每个li的left值：100*i；否则，就是：100*i+700
                          4.鼠标离开事件的时候，再次遍历lis，让每个li恢复到初始left值：240*i


7.定位版本的手风琴(问道)：
    思路：1.上面的定位版本的li里面就是一张完整的图片，但是这里的一个li里面包含两块图片，给最外面的box大盒子设置相对            定位，给li设置绝对定位，
          2.首先找到对象，通过dt或者dd遍历给每个dt和dd设置背景图片，并且设置初始li的left值：判断如果i=0的时候，一个li的left的值就是0，否则就是一张li的大小510 + 116 * i + &#39;px&#39; ;并且保存每个li的索引值i
          3.给每个li注册鼠标经过事件，遍历lis，判断每个li的索引值i的值小于等于当前经过的this.index的值的时候，调用animate方法，给lis[i],设置left值：116 * i ；否则就是 510 + 116 * i；


8.旋转木马：1.一个大盒子里面嵌套两个兄弟盒子；一个是包裹着ul li图片的，一个是包裹着左右箭头的a标签  
            2.首先编写一组li所在位置的配置单，有层级和透明度，找到对象，让每个li跑到自己所在的位置：animate(lis[i],datas[i])
            3.鼠标经过盒子，让箭头渐渐的显示，鼠标离开盒子，让箭头渐渐地隐藏
            4.定义一个截阀流，flag = true ；先假设水龙头是开着的；点击右箭头，首先就是让flag水龙头关闭，flag = false ；然后再做相应的操作：把配置单的后面一组数据添加到配置单的最前面，然后再进行遍历，重新各就各位，最后把节流阀打开
            if(flag) {
                flag = false ;
                datas.unshift(datas.pop()) ;
                for(var i = 0 ; i &lt; datas.length ; i ++) {
                    animate(lis[i],datas[i],function(){
                        flag = true ;7
                    })
                }
            }

            5.点击左箭头，也有一个截阀流，这个时候的操作只是把配置单的前面一个添加到配置单的最后
            if(flag) {
                flag = false ;
                datas.push(datas.shift()) ;
                for(var i = 0 ; i &lt; datas.length ; i ++) {
                    animate(lis[i],datas[i],function(){
                        flag = true ;
                    })
                }
            }

9.仿腾讯固定定位案例：利用滚动事件，和margin-top来设置固定定位。
    思路：给页面注册滚动事件，获取到topPart的自身高度 和  navBar的自身高度；
            判断当滚动的头部大于等于topPart的自身高度的时候，让navBar固定定位，并且让mainPart的marginTop ：navHeight + 10 + ‘px’；否则，就是没有固定定位，并且mainPart的marginTop：10 + ‘px’ ；


10.瀑布流布局： 
    //思路：
    //1. 对于第一行图片来说，直接左浮动即可。
    //2. 对于其他图片，需要使用定位定过去，每次都定位到最小列那里去。

    //1. 要确定第一行有多少张图片
        思路：获取页面的宽度：getClient().width ; 获取一张图片的宽度：demos[0].offsetWidth ; 把两个数相除取整parseInt得到columns
    //2. 我可以把第一行里面的图片的高度，存放到一个数组里面去。[111,22,44,66,88,190]
        思路：定义一个空数组，遍历columns，获取到每个第一行demo的自身高度,追加到arr数组里去保存
    //3. 通过数组就能找到最小列。对于第一列后面的那些图片，就可以定位到最小列。
        思路：对于第一行保存好高度后，遍历第一行以后的图片，定义index = getMin(arr) ; 设置绝对定位
                给div.style.left = demos(index).offsetLeft + &#39;px&#39; ;
                div.style.top = arr[index] + &#39;px&#39; ;
    //4. 添加了一张图片之后，数组是变化了，[111,122,44,66,88,190]
                //重新排列数组
                arr[index] = arr[index] + div.offsetHeight ;

    //5.//确定什么时候去加载图片。当最后一张图片出现的时候，就加载图片。
            //当可视区域的高度+页面卷去的高度&gt;= 最后一张图片的offfsetTop的时候，就要加载图片了
        思路：获取页面可视高度，和滚动的头部高度，再获取最后一张图片的自身高度，判断可视高度+滚动的头部高度 》= 最后一张图片的时候添加图片数据
                创建div，设置类名demos，innerHTML 的内容：&#39;&lt;img src=&quot;&#39;+datas[i].src+&#39;&quot; alt=&quot;&quot;&gt;&#39;; 追加到box里，然后再进行绝对定位，找到最小列的项，和2的步骤一致。


11.    让天使飞 --&gt; 1.通过给页面注册鼠标移动事件，获取事件对象，获取到页面xy点的坐标。
                2.给小天使绝对定位，并且设置左边和顶部的坐标。或者给小天使设置固定定位，获取页面可视的xy坐标即可:x = e.clientX; y = e.clientY ;
                xy坐标：
                getPage(e){
                    return {
                        x: e.pageX || e.clientX + getScroll().left ,
                        y: e.pageY || e.clientY + getScroll().top
                    }
                }    

12.获取鼠标在盒子里的坐标：先获取整个页面的xy坐标，再分别减去盒子自身距离左边的真实距离，减去盒子距离顶部的真实距离
     box.onclick = function (e) {
        e = e || window.event;
        //我要获取鼠标在box里面点击的位置
        var pageX = getPage(e).x;
        var pageY = getPage(e).y;

        var spaceX = pageX - box.offsetLeft;
        var spaceY = pageY - box.offsetTop;

        console.log(spaceX);
        console.log(spaceY);

    }     

13.放大镜：1.一个大盒子里面包裹两个兄弟盒子；一个放小图和遮罩，一个放大图，移动的光标是cursor:move ;
        鼠标经过小盒子，让遮罩和大盒子显示，鼠标离开盒子，让遮罩和大盒子隐藏
        思路：1.先获取鼠标在盒子里的坐标；
        2.再让鼠标在mask的中间:x = spaceX - mask.offsetWidth / 2 ; y = spaceY - mask.offsetHeight / 2 ;
        3.限定mask的活动范围：if(x &lt; 0 ) {x = 0 } ;var maxXMax = smallBox.offsetWidth - mask.offsetWidth ;
                                if(x &gt; maxXMax) {x = maxXMax} ;if(y &lt; 0) {y = 0 } var maxYMax = smallBox.offsetHeight - mask.offsetHeight ;if(y &gt; maxYMax) {y = maxYMax} ;
                再设置mask的left和top的位置：mask.style.left = x + &quot;px&quot;; mask.style.top = y + &quot;px&quot;;
        4.等比例移动大图
            mask移动的距离 / mask能够移动的距离 = 大图移动的距离 / 大图能够移动的距离
            var xRate = x / maxXMax ;bigImg.style.left = -xRate * (bigImg.offsetWidth - bigBox.offsetWidth) + &#39;px&#39;;
            var yRate = y / maxYMax ;  bigImg.style.top = - yRate * (bigImg.offsetHeight - bigBox.offsetHeight)+ &quot;px&quot;;
}


14.可拖拽效果：注册鼠标按下，拖拽事件开始：获取鼠标在盒子的位置，在鼠标按下事件中注册页面移动事件，获取页面的坐标，最后设置盒                子的left和top的位置：页面的坐标 减去 鼠标在盒子上的坐标 ；
                注册鼠标弹起事件，拖拽结束：在弹起事件中，给页面注册鼠标移动事件 = null； 就清除了拖拽事件。

                box.onmousedown = function(e) {
                    e = e || window.event ;
                    var spaceX = getPage(e).x - box.offsetLeft ;
                    var spaceY = getPage(e).y - box.offsetTop ;

                    document.onmousemove = function(e) {
                        e = e || window.event ;
                        var pageX = getPage(e).x ;
                        var pageY = getPage(e).y ;
                        box.style.left = pageX - spaceX + &#39;px&#39; ;
                        box.style.top = pageY - spaceY + &#39;px&#39; ;
                    }
                }
                box.onmouseup = function() {
                    document.onmousemove = null ;
                }

15.弹幕效果：获取在输入框的值，动态创建一个span标签，他的innerHTML就是输入框的值，添加到大盒子里去，定义一个颜色数组，随机颜色给span设置color随机，文字在                随机跑：要获取页面的宽度，设置span的初始left和top值随机，让span渐渐地跑到最左边，不见了要删除这个span removeChild,当发射出去文字后要让文本框清空；
            2.获得键盘enter的keycode值，按下enter键触发点击事件。
</code></pre>
          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>